# ============================================================
# app.py ‚Äî DenseNet121_BinaryClassifier Ï†ÑÏö©, Î∂ÑÎ¶¨Ìòï Grad-CAM ÌôïÏã§ ÏûëÎèô Î≤ÑÏ†Ñ
# ============================================================

import os
from pathlib import Path
import numpy as np
import streamlit as st
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.applications.densenet import preprocess_input
from PIL import Image
import cv2
import gdown, requests

# ----------------------- Í∏∞Î≥∏ ÏÑ§Ï†ï -----------------------
st.set_page_config(page_title="CXR Pneumonia ‚Äî DenseNet121 + Grad-CAM", layout="wide")
CLASS_NAMES = ["NORMAL", "PNEUMONIA"]
IMG_SIZE = (224, 224)

MODEL_DIR = Path("models"); MODEL_DIR.mkdir(parents=True, exist_ok=True)
MODEL_LOCAL = MODEL_DIR / "densenet121_best.keras"  # ÌååÏùºÎ™ÖÏùÄ ÎÑ§Í∞Ä Ïã§Ï†ú Î∞∞Ìè¨Ìïú Ïù¥Î¶ÑÏúºÎ°ú ÎßûÏ∂îÎ©¥ Îê®
FILE_ID = st.secrets.get("MODEL_FILE_ID", "")       # gdown File ID (ÏÑ†ÌÉù)
HTTP_FALLBACK_URL = st.secrets.get("MODEL_DIRECT_URL", "")  # ÏßÅÏ†ë URL (ÏÑ†ÌÉù)
TIMEOUT = 120

# ----------------------- Îã§Ïö¥Î°úÎìú Ïú†Ìã∏ -----------------------
def _http_download(url: str, out: Path) -> bool:
    try:
        with requests.get(url, stream=True, timeout=TIMEOUT) as r:
            r.raise_for_status()
            with open(out, "wb") as f:
                for chunk in r.iter_content(1 << 20):
                    if chunk:
                        f.write(chunk)
        return out.exists() and out.stat().st_size > 0
    except Exception:
        return False

@st.cache_data(show_spinner=False)
def ensure_model_file_cached() -> str:
    if MODEL_LOCAL.exists() and MODEL_LOCAL.stat().st_size > 0:
        return str(MODEL_LOCAL)
    # 1) gdown
    if FILE_ID:
        try:
            gdown.download(id=FILE_ID, output=str(MODEL_LOCAL), quiet=False, fuzzy=True)
        except Exception:
            pass
        if MODEL_LOCAL.exists() and MODEL_LOCAL.stat().st_size > 0:
            return str(MODEL_LOCAL)
    # 2) HTTP fallback
    if HTTP_FALLBACK_URL:
        _http_download(HTTP_FALLBACK_URL, MODEL_LOCAL)
        if MODEL_LOCAL.exists() and MODEL_LOCAL.stat().st_size > 0:
            return str(MODEL_LOCAL)
    raise RuntimeError("Î™®Îç∏ Îã§Ïö¥Î°úÎìú Ïã§Ìå®")

@st.cache_resource(show_spinner=False)
def load_model(model_path: str):
    # Lambda(preprocess_input) Î≥µÏõê ÏúÑÌï¥ custom_objects Îì±Î°ù
    return keras.models.load_model(
        model_path,
        custom_objects={"preprocess_input": preprocess_input},
        safe_mode=False,
        compile=False,
    )

# ----------------------- Ï†ÑÏ≤òÎ¶¨/ÏãúÍ∞ÅÌôî -----------------------
def prepare_inputs(pil_img: Image.Image):
    pil = pil_img.convert("RGB").resize(IMG_SIZE)
    rgb_uint8 = np.array(pil, dtype=np.uint8)
    bchw_raw = np.expand_dims(rgb_uint8.astype(np.float32), axis=0)  # (1,H,W,3)
    return rgb_uint8, bchw_raw

def overlay_heatmap(rgb_uint8, heatmap, alpha=0.6):
    h, w = rgb_uint8.shape[:2]
    hm = cv2.resize(heatmap.astype(np.float32), (w, h))
    hm = np.clip(hm, 0.0, 1.0)
    hm8 = np.uint8(255 * hm)
    jet = cv2.applyColorMap(hm8, cv2.COLORMAP_JET)
    jet = cv2.cvtColor(jet, cv2.COLOR_BGR2RGB)
    return (jet * alpha + rgb_uint8 * (1 - alpha)).clip(0, 255).astype(np.uint8)

def ellipse_lung_mask(h, w, cy=0.48, rx=0.23, ry=0.32, gap=0.10):
    mask = np.zeros((h, w), np.uint8)
    cx = w // 2
    cy = int(h * cy)
    rx = int(w * rx)
    ry = int(h * ry)
    gap = int(w * gap)
    cv2.ellipse(mask, (cx - gap, cy), (rx, ry), 0, 0, 360, 255, -1)
    cv2.ellipse(mask, (cx + gap, cy), (rx, ry), 0, 0, 360, 255, -1)
    return (mask > 0).astype(np.float32)

# ----------------------- Î∂ÑÎ¶¨Ìòï Grad-CAM -----------------------
def build_feature_and_classifier(model: keras.Model, last_conv_name: str):
    """
    ÎÑ§Í∞Ä ÌïôÏäµÌïú Ï†ÑÏ≤¥ Î™®Îç∏ÏùÑ ÏïÑÎûòÏ≤òÎüº Î∂ÑÌï¥:
    - preproc: input_image -> densenet_preprocess Ï∂úÎ†•
    - backbone: DenseNet121 (base_model) Ïùò 'last_conv_name'ÍπåÏßÄ
    - classifier: (GAP -> Dropout -> Dense) Î®∏Î¶¨Î∂ÄÎ∂Ñ
    """
    # 1) ÏÑúÎ∏åÍ∑∏ÎûòÌîÑ: Ï†ÑÏ≤òÎ¶¨
    pre_in = model.get_layer("input_image").input
    pre_out = model.get_layer("densenet_preprocess").output
    preproc = keras.Model(pre_in, pre_out, name="preprocessor")

    # 2) ÏÑúÎ∏åÍ∑∏ÎûòÌîÑ: DenseNet121Ïùò ÎßàÏßÄÎßâ conv/ÌôúÏÑ±Ìôî Ï∂úÎ†•
    base = model.get_layer("densenet121")
    last_conv = base.get_layer(last_conv_name)  # Í∏∞Î≥∏ 'relu' Ï∂îÏ≤ú
    feature_extractor = keras.Model(base.input, last_conv.output, name="feature_extractor")

    # 3) ÏÑúÎ∏åÍ∑∏ÎûòÌîÑ: classifier Î®∏Î¶¨ (backbone Ïù¥ÌõÑ Î†àÏù¥Ïñ¥Îßå Ïû¨Íµ¨ÏÑ±)
    #    ÏõêÎûò Î™®Îç∏ ÏàúÏÑú: [input_image, densenet_preprocess, densenet121, GAP, Dropout, Dense]
    #    ‚Üí densenet121 Ïù¥ÌõÑ Î†àÏù¥Ïñ¥Îì§Îßå Í∑∏ÎåÄÎ°ú Ïû¨ÏÇ¨Ïö©
    classifier_in = keras.Input(shape=last_conv.output.shape[1:], name="cam_head_in")
    x = classifier_in
    for lyr in model.layers:
        if lyr.name in ["input_image", "densenet_preprocess", "densenet121"]:
            continue
        x = lyr(x)
    classifier = keras.Model(classifier_in, x, name="classifier_head")

    return preproc, feature_extractor, classifier

def gradcam_separated(img_bchw: np.ndarray, model: keras.Model, last_conv_name: str, target_class: int = 1):
    """
    Î∂ÑÎ¶¨Ìòï(Í∂åÏû•) Grad-CAM:
    - x -> preproc(x) -> feature_extractor(reluÍπåÏßÄ) -> conv_feat
    - preds = classifier(conv_feat)
    - d(preds[:,target])/d(conv_feat) Î°ú CAM ÏÉùÏÑ±
    """
    x = tf.convert_to_tensor(img_bchw, dtype=tf.float32)

    # Î∂ÑÎ¶¨ Í∑∏ÎûòÌîÑ Íµ¨ÏÑ±
    preproc, feat, head = build_feature_and_classifier(model, last_conv_name)

    # Ï†ÑÎ∞©ÌÜµÍ≥º + Gradient Í≥ÑÏÇ∞
    with tf.GradientTape() as tape:
        x_pp = preproc(x, training=False)
        conv_feat = feat(x_pp, training=False)
        tape.watch(conv_feat)

        preds = head(conv_feat, training=False)  # shape: (1,1) Ïù¥ÏßÑ
        if preds.shape[-1] == 1:
            cls = preds[:, 0] if target_class == 1 else (1.0 - preds[:, 0])
        else:
            cls = preds[:, target_class]

    grads = tape.gradient(cls, conv_feat)                 # [1,Hc,Wc,C]
    if grads is None:
        raise RuntimeError("Gradient is None ‚Äî Î†àÏù¥Ïñ¥ Ïù¥Î¶ÑÏùÑ 'relu' Îì±ÏúºÎ°ú Î∞îÍøîÎ≥¥ÏÑ∏Ïöî.")

    weights = tf.reduce_mean(grads, axis=(0, 1, 2))       # [C]
    cam = tf.reduce_sum(tf.nn.relu(conv_feat[0] * weights), axis=-1)  # [Hc,Wc]
    cam = (cam - tf.reduce_min(cam)) / (tf.reduce_max(cam) - tf.reduce_min(cam) + 1e-8)
    cam_np = cam.numpy().astype(np.float32)

    # ÏÇ¥Ïßù Î∏îÎü¨ + Í∞ÄÎ≤ºÏö¥ ÎåÄÎπÑ
    p90 = float(np.percentile(cam_np, 90.0))
    cam_np = np.clip(cam_np / (p90 + 1e-6), 0, 1)
    cam_np = cv2.GaussianBlur(cam_np, (3, 3), 0)

    return cam_np, float(preds.numpy().squeeze())

# ----------------------- Sidebar -----------------------
with st.sidebar:
    st.header("‚öôÔ∏è Settings")
    thresh = st.slider("Decision threshold (PNEUMONIA)", 0.40, 0.75, 0.69, 0.01)
    st.caption("‚Ä¢ ÎÇÆÏ∂îÎ©¥ ÎØºÍ∞êÎèÑ‚Üë ‚Ä¢ ÎÜíÏù¥Î©¥ Ï†ïÏÉÅ Î≥¥Ìò∏(Ïò§ÌÉê‚Üì)")

    st.divider()
    st.subheader("Grad-CAM layer")
    st.caption("Í∂åÏû•: DenseNet121 ÎÇ¥Î∂Ä ÎßàÏßÄÎßâ ÌôúÏÑ±Ìôî **relu**")
    # ÌïÑÏöîÏãú conv4/conv5Ïùò concatÏù¥ÎÇò reluÎ•º ÏÑ†ÌÉùÌï¥ ÎπÑÍµêÌï† Ïàò ÏûàÍ≤å ÏòµÏÖò Ï†úÍ≥µ
    # Í∏∞Î≥∏ÏùÄ 'relu' Î°ú ÎëêÍ≥†, Î™©Î°ùÏùÄ Î°úÎî© ÌõÑ Ï±ÑÏõÄ

    st.divider()
    st.subheader("Lung mask (optional)")
    use_mask = st.checkbox("Apply ellipse lung mask", value=True)
    cy = st.slider("center y", 0.35, 0.60, 0.48, 0.01)
    rx = st.slider("radius x", 0.15, 0.35, 0.23, 0.01)
    ry = st.slider("radius y", 0.20, 0.45, 0.32, 0.01)
    gap = st.slider("gap", 0.05, 0.20, 0.10, 0.01)

# ----------------------- Main -----------------------
st.title("ü©ª Chest X-ray Pneumonia ‚Äî DenseNet121 + Grad-CAM (Separated)")
st.caption("ColabÍ≥º ÎèôÏùºÌïú Í∞êÏúºÎ°ú ÎèôÏûë. ÏùòÏÇ¨Ïö© Ïû•ÎπÑÍ∞Ä ÏïÑÎãôÎãàÎã§.")

# Î™®Îç∏ Î°úÎìú
try:
    model_path = ensure_model_file_cached()
    model = load_model(model_path)
except Exception as e:
    st.error(f"Î™®Îç∏ Î°úÎî© Ïã§Ìå®: {e}")
    st.stop()

# DenseNet ÎÇ¥Î∂Ä Î†àÏù¥Ïñ¥ Î™©Î°ù(ÏÑ†ÌÉù Î∞ïÏä§Ïö©)
base = model.get_layer("densenet121")
all_names = [l.name for l in base.layers]
# ÎßàÏßÄÎßâÏóê Ïì∞Í∏∞ Ï¢ãÏùÄ ÌõÑÎ≥¥Îì§(Î®ºÏ†Ä 'relu'Í∞Ä ÏûàÏúºÎ©¥ Í∑∏Í±∏ Í∏∞Î≥∏Í∞í)
candidate_names = [n for n in all_names if ("relu" in n or "concat" in n or "conv5_block" in n)]
default_name = "relu" if "relu" in all_names else (candidate_names[-1] if candidate_names else all_names[-1])
chosen_name = st.sidebar.selectbox("Select CAM target layer", candidate_names or all_names, index=(candidate_names or all_names).index(default_name))

# ÏóÖÎ°úÎìú
up = st.file_uploader("Upload an X-ray (JPG/PNG)", type=["jpg", "jpeg", "png"])
if up:
    pil_img = Image.open(up)
    rgb_uint8, x_raw_bchw = prepare_inputs(pil_img)

    col1, col2 = st.columns(2)
    with col1:
        st.image(rgb_uint8, caption="Input (224√ó224)", use_column_width=True)

    if st.button("Run Grad-CAM"):
        with st.spinner("Running‚Ä¶"):
            try:
                # Grad-CAM (Î∂ÑÎ¶¨Ìòï)
                heatmap, p_pneu = gradcam_separated(x_raw_bchw, model, chosen_name, target_class=1)
                label = "PNEUMONIA" if p_pneu >= thresh else "NORMAL"

                if use_mask:
                    mh, mw = heatmap.shape
                    m = ellipse_lung_mask(mh, mw, cy, rx, ry, gap)
                    heatmap = heatmap * m

                cam_img = overlay_heatmap(rgb_uint8, heatmap)

                with col2:
                    st.image(cam_img, caption=f"Grad-CAM ({chosen_name})", use_column_width=True)

                m1, m2, m3 = st.columns(3)
                m1.metric("Predicted", label)
                m2.metric("Prob. PNEUMONIA", f"{p_pneu*100:.2f}%")
                m3.metric("Threshold", f"{thresh:.2f}")

            except Exception as e:
                st.error(f"Grad-CAM Ïã§Ìå®: {type(e).__name__} ‚Äî {e}")
else:
    st.info("‚¨ÜÔ∏è X-ray Ïù¥ÎØ∏ÏßÄÎ•º ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî.")
